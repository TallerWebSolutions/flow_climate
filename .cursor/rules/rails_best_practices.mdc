---
description: 
globs: 
alwaysApply: true
---
# Rails Best Practices

## Frozen String Literal Comment

All Ruby files MUST include the frozen string literal comment at the top of the file:

```ruby
# frozen_string_literal: true
```

This comment should be the first line of the file, before any other code or comments. This is a Ruby 2.3+ feature that makes all string literals in the file frozen by default, which helps prevent accidental string mutations and improves performance.

### Examples

✅ Correct:

```ruby
# frozen_string_literal: true

class MyClass
  def my_method
    "hello"
  end
end
```

❌ Incorrect:

```ruby
class MyClass
  def my_method
    "hello"
  end
end
```

### Why?

1. Performance: Frozen strings are more memory efficient as they can be reused
2. Safety: Prevents accidental string mutations
3. Consistency: Makes string behavior more predictable
4. RuboCop Compliance: Follows the Style/FrozenStringLiteralComment rule

### When to Apply

- All new Ruby files
- All Ruby files being modified
- All Ruby files in the codebase (when possible)

### Exceptions

- Files that specifically need mutable strings (very rare)
- Files that are generated by tools (like migrations)
- Files that are part of a third-party gem

### Implementation

When creating or modifying Ruby files, always ensure the frozen string literal comment is present at the top of the file. This is a simple but important practice that helps maintain code quality and performance.

## Date and Time Usage

When working with dates in Rails, always use the timezone-aware methods from `Time.zone` instead of the standard Ruby `Date` or `Time` classes.

### Examples

✅ Correct:

```ruby
# frozen_string_literal: true

class MyClass
  def my_method
    today = Time.zone.today
    now = Time.zone.now
    beginning_of_day = Time.zone.today.beginning_of_day
  end
end
```

❌ Incorrect:

```ruby
# frozen_string_literal: true

class MyClass
  def my_method
    today = Date.today
    now = Time.now
    beginning_of_day = Date.today.beginning_of_day
  end
end
```

### Why?

1. Timezone Consistency: `Time.zone` respects the application's configured timezone
2. Daylight Saving Time: Properly handles DST transitions
3. Database Consistency: Ensures dates are stored and retrieved in the same timezone
4. RuboCop Compliance: Follows the Rails/Date rule

### When to Apply

- All new Ruby files
- All Ruby files being modified
- All date/time operations in the codebase

### Methods to Use

Always prefer these timezone-aware methods:

- `Time.zone.today` instead of `Date.today`
- `Time.zone.now` instead of `Time.now`
- `Time.zone.parse` instead of `Time.parse` or `Date.parse`
- `Time.zone.at` instead of `Time.at`

### Exceptions

- When explicitly working with UTC times (use `Time.utc`)
- When dealing with external APIs that require specific timezone handling
- When working with legacy code that hasn't been updated yet

### Implementation

When creating or modifying Ruby files that handle dates and times:

1. Always use `Time.zone` methods
2. Be consistent with timezone usage throughout the application
3. Document any timezone-specific requirements
4. Consider timezone implications when working with external systems

## Boolean Columns

When creating boolean columns in the database, always include a default value and a `NOT NULL` constraint. This prevents the "three-state boolean" problem where a boolean column can be `true`, `false`, or `NULL`.

### Examples

✅ Correct:

```ruby
# frozen_string_literal: true

class CreateUsers < ActiveRecord::Migration[7.0]
  def change
    create_table :users do |t|
      t.boolean :active, null: false, default: true
      t.boolean :admin, null: false, default: false
    end
  end
end
```

❌ Incorrect:

```ruby
# frozen_string_literal: true

class CreateUsers < ActiveRecord::Migration[7.0]
  def change
    create_table :users do |t|
      t.boolean :active
      t.boolean :admin, default: false
    end
  end
end
```

### Why?

1. Data Integrity: Prevents ambiguous states in boolean columns
2. Query Simplicity: Makes queries more straightforward (no need to check for NULL)
3. Code Clarity: Makes the code's intent clearer
4. RuboCop Compliance: Follows the Rails/ThreeStateBooleanColumn rule

### When to Apply

- All new migrations
- All modifications to existing boolean columns
- All model validations involving boolean fields

### Implementation Guidelines

1. Always specify both `null: false` and `default: value` for boolean columns
2. Choose appropriate default values based on business logic
3. Document the meaning of boolean values in the model
4. Consider adding model validations to enforce boolean constraints

### Default Value Selection

Choose default values that make sense for your business logic:

- `true` for features that are enabled by default
- `false` for features that are disabled by default
- Consider the most common or safest state as the default

### Exceptions

- When working with legacy databases that can't be modified
- When the boolean column genuinely needs to support NULL values (very rare)
- When dealing with third-party schemas that can't be changed

### Model Validations

Consider adding validations in your models to enforce boolean constraints:

```ruby
# frozen_string_literal: true

class User < ApplicationRecord
  validates :active, inclusion: { in: [true, false] }
  validates :admin, inclusion: { in: [true, false] }
end
```
